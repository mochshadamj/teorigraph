<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lintasan/Sirkuit Euler dan Hamilton</title>
    <link rel="stylesheet" href="css/index.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”— Analisis Lintasan/Sirkuit Euler dan Hamilton</h1>
            <p>Buat graph dan analisis lintasan/sirkuit Euler dan Hamilton</p>
        </div>

        <div class="controls">
            <div class="control-panel">
                <h3>ğŸ¯ Kontrol Graph</h3>
                <div class="input-group">
                    <label>Jumlah Titik/Node:</label>
                    <input type="number" id="numVertices" value="5" min="3" max="10">
                </div>
                <div class="predefined-graphs">
                    <button class="btn btn-secondary" onclick="createCompleteGraph()">Graph Lengkap</button>
                    <button class="btn btn-secondary" onclick="createCycleGraph()">Graph Bulat</button>
                    <button class="btn btn-secondary" onclick="createPathGraph()">Graph Lintasan</button>
                </div>
                <div style="margin-top: 15px;">
                    <button class="btn" onclick="generateRandomGraph()">ğŸ² Graph Acak</button>
                    <button class="btn btn-danger" onclick="clearGraph()">ğŸ—‘ï¸ Hapus Semua Graph</button>
                </div>
            </div>

            <div class="control-panel">
                <h3>âš™ï¸ Analisis</h3>
                <button class="btn" onclick="analyzeGraph()" style="width: 100%; margin-bottom: 10px;">
                    ğŸ” Analisis Graph
                </button>
                <button class="btn btn-secondary" onclick="showAdjacencyMatrix()" style="width: 100%; margin-bottom: 10px;">
                    ğŸ“Š Tampilkan Matrix
                </button>
                <button class="btn btn-secondary" onclick="animatePath()" style="width: 100%;">
                    ğŸ¬ Animasi Lintasan
                </button>
            </div>
        </div>

        <div class="main-content">
            <div class="canvas-container">
                <h3 style="text-align: center; margin-bottom: 15px; color: #495057;">ğŸ“ˆ Visualisasi</h3>
                <canvas id="graphCanvas" width="500" height="400"></canvas>
                <div style="text-align: center; margin-top: 10px;">
                    <button class="help-btn" onclick="openInstructionsModal()">
                        â“ Bantuan & Instruksi
                    </button>
                </div>
            </div>

            <div class="results">
                <h3 style="margin-bottom: 20px; color: #495057;">ğŸ“‹ Hasil Analisis</h3>
                
                <div class="result-section">
                    <h4>ğŸƒâ€â™‚ï¸ Lintasan Euler</h4>
                    <div id="eulerPathStatus" class="status"></div>
                    <div id="eulerPathResult" class="result-content"></div>
                </div>

                <div class="result-section">
                    <h4>ğŸ” Sirkuit Euler</h4>
                    <div id="eulerCircuitStatus" class="status"></div>
                    <div id="eulerCircuitResult" class="result-content"></div>
                </div>

                <div class="result-section">
                    <h4>ğŸƒâ€â™‚ï¸ Lintasan Hamilton</h4>
                    <div id="hamiltonPathStatus" class="status"></div>
                    <div id="hamiltonPathResult" class="result-content"></div>
                </div>

                <div class="result-section">
                    <h4>ğŸ” Sirkuit Hamilton</h4>
                    <div id="hamiltonCircuitStatus" class="status"></div>
                    <div id="hamiltonCircuitResult" class="result-content"></div>
                </div>

                <div class="result-section">
                    <h4>ğŸ“Š Informasi Graph</h4>
                    <div id="graphInfo" class="result-content"></div>
                </div>

                <div class="result-section">
                    <h4>ğŸ”¢ Pendekatan Matrix</h4>
                    <div id="matrixDisplay" class="matrix-display"></div>
                </div>
            </div>
        </div>

        <div class="theory-buttons">
            <button class="theory-btn" onclick="openTheoryModal('euler')">
                ğŸƒâ€â™‚ï¸ Apa itu Euler?
            </button>
            <button class="theory-btn" onclick="openTheoryModal('hamilton')">
                ğŸ”„ Apa itu Hamilton?
            </button>
            <button class="theory-btn" onclick="openTheoryModal('graph-basics')">
                ğŸ“š Dasar-dasar Graf
            </button>
            <button class="theory-btn" onclick="openTheoryModal('differences')">
                âš–ï¸ Perbedaan Keduanya
            </button>
            <button class="theory-btn" onclick="openTheoryModal('applications')">
                ğŸŒŸ Aplikasi Real Life
            </button>
        </div>

        <!-- Modal untuk teori Euler -->
        <div id="eulerTheoryModal" class="theory-modal">
            <div class="theory-modal-content">
                <div class="theory-modal-header">
                    <h2>ğŸƒâ€â™‚ï¸ Lintasan & Sirkuit Euler</h2>
                    <span class="theory-close" onclick="closeTheoryModal('euler')">&times;</span>
                </div>
                <div class="theory-modal-body">
                    <div class="theory-section">
                        <h3>ğŸ¤” Apa sih Euler itu?</h3>
                        <p>Jadi gini bestie, <span class="highlight">Leonhard Euler</span> itu matematikawan Swiss yang super jenius! Dia hidup di abad ke-18 dan bikin teori yang sampai sekarang masih kepake banget.</p>
                        
                        <div class="tips-box">
                            <strong>ğŸ’¡ Fun Fact:</strong> Euler itu udah buta sebelah mata sejak muda, tapi tetep jadi salah satu matematikawan terhebat sepanjang masa! Inspiratif banget kan? ğŸ”¥
                        </div>
                    </div>
                    
                    <div class="theory-section">
                        <h3>ğŸƒâ€â™‚ï¸ Lintasan Euler</h3>
                        <p>Lintasan Euler tuh ibarat kamu jalan-jalan di kota, dan kamu pengen <span class="highlight">lewatin semua jalan tepat sekali</span> tanpa ngulang. Keren kan?</p>
                        
                        <div class="formula">
                            Syarat Lintasan Euler: Tepat 2 titik berderajat ganjil
                        </div>
                        
                        <div class="example-box">
                            <strong>ğŸŒŸ Contoh Gampang:</strong> Bayangin kamu di Bandung mau jalan dari Dago ke Cihampelas, terus ke Braga, balik ke Dago tapi lewat jalan yang beda. Nah itu lintasan Euler!
                        </div>
                    </div>
                    
                    <div class="theory-section">
                        <h3>ğŸ” Sirkuit Euler</h3>
                        <p>Kalo sirkuit Euler itu lebih kece lagi! Kamu jalan-jalan <span class="highlight">lewatin semua jalan tepat sekali</span> terus balik lagi ke titik awal. Kayak pulang pergi gitu deh!</p>
                        
                        <div class="formula">
                            Syarat Sirkuit Euler: Semua titik berderajat genap
                        </div>
                        
                        <div class="tips-box">
                            <strong>ğŸ¯ Tips Jitu:</strong> Inget aja, kalo mau ada sirkuit Euler, semua titik harus punya "temen" genap. Gak boleh ada yang jomblo! ğŸ˜‚
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Modal untuk teori Hamilton -->
        <div id="hamiltonTheoryModal" class="theory-modal">
            <div class="theory-modal-content">
                <div class="theory-modal-header">
                    <h2>ğŸ”„ Lintasan & Sirkuit Hamilton</h2>
                    <span class="theory-close" onclick="closeTheoryModal('hamilton')">&times;</span>
                </div>
                <div class="theory-modal-body">
                    <div class="theory-section">
                        <h3>ğŸ§  Siapa itu Hamilton?</h3>
                        <p><span class="highlight">William Rowan Hamilton</span> itu matematikawan Irlandia yang bikin konsep ini. Fun fact: dia juga yang nemuin quaternion lho! Pinter banget emang ğŸ¤“</p>
                    </div>
                    
                    <div class="theory-section">
                        <h3>ğŸƒâ€â™‚ï¸ Lintasan Hamilton</h3>
                        <p>Nah kalo Hamilton itu beda sama Euler. Kalo Euler fokus ke <span class="highlight">edge/sisi</span>, Hamilton fokus ke <span class="highlight">vertex/titik</span>!</p>
                        <p>Jadi lintasan Hamilton itu kamu harus <span class="highlight">kunjungi setiap titik tepat sekali</span>. Kayak main monopoli tapi gak boleh lewat kotak yang sama dua kali!</p>
                        
                        <div class="example-box">
                            <strong>ğŸ® Analogi Game:</strong> Bayangin kamu main game RPG, terus ada 5 kota yang harus dikunjungi. Lintasan Hamilton itu rute yang ngunjungin setiap kota tepat sekali tanpa balik-balik!
                        </div>
                    </div>
                    
                    <div class="theory-section">
                        <h3>ğŸ” Sirkuit Hamilton</h3>
                        <p>Sirkuit Hamilton itu yang paling epic! Kamu <span class="highlight">kunjungi setiap titik tepat sekali</span> dan akhirnya balik ke titik awal.</p>
                        
                        <div class="tips-box">
                            <strong>ğŸ¯ Pro Tips:</strong> Hamilton itu susah banget dicari algoritmanya! Makanya banyak yang pake brute force atau backtracking. Sabar ya bestie! ğŸ’ª
                        </div>
                        
                        <div class="formula">
                            Kondisi Dirac: Jika setiap titik berderajat â‰¥ n/2, 
                            maka pasti ada sirkuit Hamilton
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Modal untuk dasar-dasar graf -->
        <div id="graphBasicsTheoryModal" class="theory-modal">
            <div class="theory-modal-content">
                <div class="theory-modal-header">
                    <h2>ğŸ“š Dasar-dasar Teori Graf</h2>
                    <span class="theory-close" onclick="closeTheoryModal('graph-basics')">&times;</span>
                </div>
                <div class="theory-modal-body">
                    <div class="theory-section">
                        <h3>ğŸ¤·â€â™€ï¸ Graf itu apaan sih?</h3>
                        <p>Graf itu bukan grafik ya bestie! ğŸ˜… Graf itu struktur matematika yang terdiri dari <span class="highlight">titik (vertex)</span> dan <span class="highlight">garis (edge)</span> yang menghubungkan titik-titik tersebut.</p>
                        
                        <div class="example-box">
                            <strong>ğŸŒ Contoh Real:</strong>
                            <ul>
                                <li>ğŸš‡ Peta MRT - titik = stasiun, garis = rel</li>
                                <li>ğŸ“± Media sosial - titik = orang, garis = pertemanan</li>
                                <li>ğŸŒ Internet - titik = website, garis = link</li>
                                <li>ğŸ—ºï¸ Peta jalan - titik = persimpangan, garis = jalan</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="theory-section">
                        <h3>ğŸ“ Istilah-istilah Penting</h3>
                        <p><strong>Vertex/Node/Titik:</strong> Bulatan-bulatan yang kamu klik itu!</p>
                        <p><strong>Edge/Sisi:</strong> Garis yang menghubungkan dua titik</p>
                        <p><strong>Degree/Derajat:</strong> Jumlah garis yang nyambung ke satu titik</p>
                        
                        <div class="tips-box">
                            <strong>ğŸ§® Rumus Ajaib:</strong> Total semua derajat = 2 Ã— jumlah edge<br>
                            Kenapa? Karena setiap edge dihitung 2 kali (dari kedua ujungnya)! ğŸ¤¯
                        </div>
                    </div>

                    <div class="theory-section">
                        <h3>ğŸ¨ Jenis-jenis Graf</h3>
                        <p><strong>ğŸ”— Graf Sederhana:</strong> Gak ada edge ganda, gak ada loop</p>
                        <p><strong>ğŸŒŸ Graf Lengkap:</strong> Setiap titik terhubung ke semua titik lain</p>
                        <p><strong>â­• Graf Siklus:</strong> Bentuk lingkaran gitu deh!</p>
                        <p><strong>ğŸ“ Graf Lintasan:</strong> Bentuk garis lurus</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Modal untuk perbedaan -->
        <div id="differencesTheoryModal" class="theory-modal">
            <div class="theory-modal-content">
                <div class="theory-modal-header">
                    <h2>âš–ï¸ Euler vs Hamilton</h2>
                    <span class="theory-close" onclick="closeTheoryModal('differences')">&times;</span>
                </div>
                <div class="theory-modal-body">
                    <div class="theory-section">
                        <h3>ğŸ¥Š Battle of the Paths!</h3>
                        <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                            <tr style="background: linear-gradient(45deg, #667eea, #764ba2); color: white;">
                                <th style="padding: 15px; text-align: left;">Aspek</th>
                                <th style="padding: 15px; text-align: left;">ğŸƒâ€â™‚ï¸ Euler</th>
                                <th style="padding: 15px; text-align: left;">ğŸ”„ Hamilton</th>
                            </tr>
                            <tr style="background: #f8f9fa;">
                                <td style="padding: 10px; font-weight: bold;">Fokus</td>
                                <td style="padding: 10px;">Edge/Sisi/Jalan</td>
                                <td style="padding: 10px;">Vertex/Titik/Kota</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px; font-weight: bold;">Aturan</td>
                                <td style="padding: 10px;">Lewati setiap JALAN sekali</td>
                                <td style="padding: 10px;">Kunjungi setiap KOTA sekali</td>
                            </tr>
                            <tr style="background: #f8f9fa;">
                                <td style="padding: 10px; font-weight: bold;">Kesulitan</td>
                                <td style="padding: 10px;">Mudah dicek ğŸ˜</td>
                                <td style="padding: 10px;">Susah banget! ğŸ˜µ</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px; font-weight: bold;">Syarat</td>
                                <td style="padding: 10px;">Lihat derajat titik</td>
                                <td style="padding: 10px;">Harus dicoba satu-satu</td>
                            </tr>
                        </table>
                        
                        <div class="tips-box">
                            <strong>ğŸ¯ Inget Gampangnya:</strong><br>
                            â€¢ <strong>Euler</strong> = jalan-jalan tanpa ngulang JALAN<br>
                            â€¢ <strong>Hamilton</strong> = wisata tanpa ngulang TEMPAT
                        </div>
                    </div>
                    
                    <div class="theory-section">
                        <h3>ğŸ§© Mana yang Lebih Susah?</h3>
                        <p>Hamilton itu <span class="highlight">jauh lebih susah</span> dari Euler! Kenapa?</p>
                        
                        <div class="example-box">
                            <strong>ğŸƒâ€â™‚ï¸ Euler:</strong> Tinggal hitung derajat titik. Ganjil berapa? Kalau 0 atau 2, beres! Gampang kan? ğŸ˜„<br><br>
                            <strong>ğŸ”„ Hamilton:</strong> Harus coba satu-satu semua kemungkinan rute. Kalau ada 10 kota, kemungkinannya bisa jutaan! Pusing! ğŸ¤¯
                        </div>
                        
                        <div class="formula">
                            Kompleksitas Hamilton: O(n!) - Faktorial!
                            10 kota = 3,628,800 kemungkinan! ğŸ˜±
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Modal untuk aplikasi -->
        <div id="applicationsTheoryModal" class="theory-modal">
            <div class="theory-modal-content">
                <div class="theory-modal-header">
                    <h2>ğŸŒŸ Aplikasi di Dunia Nyata</h2>
                    <span class="theory-close" onclick="closeTheoryModal('applications')">&times;</span>
                </div>
                <div class="theory-modal-body">
                    <div class="theory-section">
                        <h3>ğŸƒâ€â™‚ï¸ Euler di Kehidupan Sehari-hari</h3>
                        
                        <div class="example-box">
                            <strong>ğŸš› Delivery Service:</strong> Abang Gojek/Grab pengen lewatin semua jalan di suatu area tanpa ngulang. Euler path is the way! ğŸ›µ
                        </div>
                        
                        <div class="example-box">
                            <strong>ğŸ§¹ Robot Vacuum:</strong> Roomba kamu pake algoritma mirip Euler buat bersihin lantai tanpa ngulang area yang sama! ğŸ¤–
                        </div>
                        
                        <div class="example-box">
                            <strong>ğŸ® Game Design:</strong> Bikin maze atau puzzle game yang harus dilalui tanpa ngulang jalur! ğŸ¯
                        </div>
                    </div>
                    
                    <div class="theory-section">
                        <h3>ğŸ”„ Hamilton dalam Industri</h3>
                        
                        <div class="example-box">
                            <strong>ğŸšš Traveling Salesman:</strong> Sales yang mau kunjungi semua kota dengan jarak minimum. Classic Hamilton problem! ğŸ’¼
                        </div>
                        
                        <div class="example-box">
                            <strong>ğŸ­ Manufacturing:</strong> Mesin produksi yang harus ngerjain semua part tanpa nge-skip, dengan waktu minimum! âš™ï¸
                        </div>
                        
                        <div class="example-box">
                            <strong>ğŸ§¬ DNA Sequencing:</strong> Nyusun urutan DNA dengan algoritma Hamilton. Canggih banget! ğŸ”¬
                        </div>
                        
                        <div class="example-box">
                            <strong>ğŸµ Music Theory:</strong> Bikin komposisi musik yang pake semua nada tanpa ngulang! ğŸ¶
                        </div>
                    </div>
                    
                    <div class="theory-section">
                        <h3>ğŸ’° Di Dunia Bisnis & Tech</h3>
                        
                        <div class="tips-box">
                            <strong>ğŸš€ Startup Ideas:</strong>
                            <ul>
                                <li>App optimasi rute kurir</li>
                                <li>Smart city traffic management</li>
                                <li>Game puzzle berbasis graf</li>
                                <li>Social network analysis</li>
                                <li>Supply chain optimization</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="theory-section">
                        <h3>ğŸ“ Kenapa Harus Belajar Ini?</h3>
                        <p>Teori graf itu <span class="highlight">everywhere</span> banget di tech industry!</p>
                        <p>â€¢ <strong>Google Maps:</strong> Shortest path algorithms</p>
                        <p>â€¢ <strong>Facebook:</strong> Friend recommendation</p>
                        <p>â€¢ <strong>Netflix:</strong> Content recommendation system</p>
                        <p>â€¢ <strong>Uber:</strong> Driver-passenger matching</p>
                        
                        <div class="formula">
                            Graf Theory = Kunci sukses di tech industry! ğŸ”‘âœ¨
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal Instruksi -->
    <div id="instructionsModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeInstructionsModal()">&times;</span>
            <h2 style="color: #333; margin-bottom: 20px; text-align: center;">
                ğŸ“‹ Panduan Penggunaan Graph Analyzer
            </h2>

            <div class="instructions-wrapper">
                <div class="instruction-item">
                    <div class="instruction-icon">â•</div>
                    <div>
                        <strong>Menambah Node:</strong> Klik pada area kosong di canvas untuk menambahkan node baru
                    </div>
                </div>
                
                <div class="instruction-item">
                    <div class="instruction-icon">ğŸ”—</div>
                    <div>
                        <strong>Menambah Edge:</strong> Drag dari satu node ke node lain untuk membuat koneksi
                    </div>
                </div>
                
                <div class="instruction-item">
                    <div class="instruction-icon">ğŸ—‘ï¸</div>
                    <div>
                        <strong>Menghapus Node:</strong> Klik kanan pada node yang ingin dihapus
                    </div>
                </div>
                
                <div class="instruction-item">
                    <div class="instruction-icon">âœ‚ï¸</div>
                    <div>
                        <strong>Menghapus Edge:</strong> Klik kanan pada garis edge yang ingin dihapus
                    </div>
                </div>
                
                <div class="instruction-item">
                    <div class="instruction-icon">ğŸ¯</div>
                    <div>
                        <strong>Memilih Node:</strong> Klik pada node untuk memilih (akan berubah warna merah)
                    </div>
                </div>
                
                <div class="instruction-item">
                    <div class="instruction-icon">ğŸ”</div>
                    <div>
                        <strong>Analisis:</strong> Gunakan tombol "Analisis Graph" untuk melihat hasil Euler dan Hamilton
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class Graph {
            constructor() {
                this.vertices = new Map();
                this.edges = [];
                this.nextVertexId = 0;
            }

            addVertex(x, y, label = null) {
                const id = label !== null ? label : this.nextVertexId++;
                this.vertices.set(id, { x, y, id, label: id.toString() });
                return id;
            }

            addEdge(v1, v2) {
                if (this.vertices.has(v1) && this.vertices.has(v2) && v1 !== v2) {
                    const exists = this.edges.some(edge => 
                        (edge.v1 === v1 && edge.v2 === v2) || 
                        (edge.v1 === v2 && edge.v2 === v1)
                    );
                    if (!exists) {
                        this.edges.push({ v1, v2 });
                        return true;
                    }
                }
                return false;
            }

            removeVertex(id) {
                this.vertices.delete(id);
                this.edges = this.edges.filter(edge => edge.v1 !== id && edge.v2 !== id);
            }

            removeEdge(v1, v2) {
                this.edges = this.edges.filter(edge => 
                    !((edge.v1 === v1 && edge.v2 === v2) || 
                      (edge.v1 === v2 && edge.v2 === v1))
                );
            }

            getAdjacencyList() {
                const adj = new Map();
                for (let vertex of this.vertices.keys()) {
                    adj.set(vertex, []);
                }
                for (let edge of this.edges) {
                    adj.get(edge.v1).push(edge.v2);
                    adj.get(edge.v2).push(edge.v1);
                }
                return adj;
            }

            getDegree(vertex) {
                return this.edges.filter(edge => edge.v1 === vertex || edge.v2 === vertex).length;
            }

            clear() {
                this.vertices.clear();
                this.edges = [];
                this.nextVertexId = 0;
            }
        }

        class GraphAnalyzer {
            constructor(graph) {
                this.graph = graph;
            }

            hasEulerPath() {
                const degrees = [];
                for (let vertex of this.graph.vertices.keys()) {
                    degrees.push(this.graph.getDegree(vertex));
                }
                
                const oddDegrees = degrees.filter(d => d % 2 === 1);
                return {
                    hasPath: oddDegrees.length === 0 || oddDegrees.length === 2,
                    hasCircuit: oddDegrees.length === 0,
                    oddVertices: oddDegrees.length
                };
            }

            findEulerPath() {
                const eulerInfo = this.hasEulerPath();
                if (!eulerInfo.hasPath) {
                    return null;
                }

                const adj = this.graph.getAdjacencyList();
                const tempAdj = new Map();
                
                for (let [vertex, neighbors] of adj) {
                    tempAdj.set(vertex, [...neighbors]);
                }

                let startVertex = this.graph.vertices.keys().next().value;
                
                if (!eulerInfo.hasCircuit) {
                    for (let vertex of this.graph.vertices.keys()) {
                        if (this.graph.getDegree(vertex) % 2 === 1) {
                            startVertex = vertex;
                            break;
                        }
                    }
                }

                const path = [];
                const stack = [startVertex];

                while (stack.length > 0) {
                    const current = stack[stack.length - 1];
                    if (tempAdj.get(current).length > 0) {
                        const next = tempAdj.get(current).pop();
                        tempAdj.get(next).splice(tempAdj.get(next).indexOf(current), 1);
                        stack.push(next);
                    } else {
                        path.push(stack.pop());
                    }
                }

                return path.reverse();
            }

            hasHamiltonPath() {
                const vertices = Array.from(this.graph.vertices.keys());
                const n = vertices.length;
                
                if (n < 3) return { hasPath: false, hasCircuit: false };

                let minDegree = Infinity;
                for (let vertex of vertices) {
                    const degree = this.graph.getDegree(vertex);
                    minDegree = Math.min(minDegree, degree);
                }

                const diracCondition = minDegree >= n / 2;
                
                return {
                    hasPath: this.findHamiltonPathBacktrack(vertices),
                    hasCircuit: this.findHamiltonCircuitBacktrack(vertices),
                    diracCondition: diracCondition
                };
            }

            findHamiltonPathBacktrack(vertices) {
                const n = vertices.length;
                const adj = this.graph.getAdjacencyList();
                
                for (let start of vertices) {
                    const visited = new Set();
                    const path = [];
                    
                    if (this.hamiltonPathUtil(start, visited, path, adj, n)) {
                        return path;
                    }
                }
                return null;
            }

            hamiltonPathUtil(vertex, visited, path, adj, n) {
                visited.add(vertex);
                path.push(vertex);

                if (path.length === n) {
                    return true;
                }

                for (let neighbor of adj.get(vertex)) {
                    if (!visited.has(neighbor)) {
                        if (this.hamiltonPathUtil(neighbor, visited, path, adj, n)) {
                            return true;
                        }
                    }
                }

                visited.delete(vertex);
                path.pop();
                return false;
            }

            findHamiltonCircuitBacktrack(vertices) {
                const n = vertices.length;
                const adj = this.graph.getAdjacencyList();
                
                const visited = new Set();
                const path = [];
                const start = vertices[0];
                
                if (this.hamiltonCircuitUtil(start, start, visited, path, adj, n)) {
                    return path;
                }
                return null;
            }

            hamiltonCircuitUtil(current, start, visited, path, adj, n) {
                visited.add(current);
                path.push(current);

                if (path.length === n) {
                    if (adj.get(current).includes(start)) {
                        path.push(start);
                        return true;
                    }
                    visited.delete(current);
                    path.pop();
                    return false;
                }

                for (let neighbor of adj.get(current)) {
                    if (!visited.has(neighbor)) {
                        if (this.hamiltonCircuitUtil(neighbor, start, visited, path, adj, n)) {
                            return true;
                        }
                    }
                }

                visited.delete(current);
                path.pop();
                return false;
            }
        }

        // Global variables
        let graph = new Graph();
        let canvas, ctx;
        let selectedVertex = null;
        let animationRunning = false;
        let isDragging = false;
        let dragStartVertex = null;
        let mousePos = { x: 0, y: 0 };
        let lastClickTime = 0;
        let clickThreshold = 200;
        let hoveredEdge = null;
        let hoveredVertex = null;
        let dragCompleted = false;
        let pathAnimationRunning = false;
        let animationSpeed = 1500;
        let explorationPaths = [];
        let permanentGreenPaths = [];
        let permanentGreenVertices = new Set();

        // Initialize
        window.onload = function() {
            canvas = document.getElementById('graphCanvas');
            ctx = canvas.getContext('2d');
            
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('contextmenu', handleRightClick);
            canvas.addEventListener('mouseleave', function() {
                hoveredEdge = null;
                hoveredVertex = null;
                updateCanvasCursor();
                drawGraph();
            });
            
            generateRandomGraph();
        };

        function handleCanvasClick(event) {
            if (isDragging || dragCompleted) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const clickedVertex = getVertexAt(x, y);
            
            if (clickedVertex !== null) {
                selectedVertex = clickedVertex;
                drawGraph();
            } else {
                let tooClose = false;
                for (let vertex of graph.vertices.values()) {
                    const dist = Math.sqrt((x - vertex.x) ** 2 + (y - vertex.y) ** 2);
                    if (dist < 40) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    const newVertexId = graph.addVertex(x, y);
                    selectedVertex = null;
                    drawGraph();
                }
            }
        }

        function handleMouseDown(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const clickedVertex = getVertexAt(x, y);
            
            if (clickedVertex !== null && event.button === 0) {
                isDragging = true;
                dragStartVertex = clickedVertex;
                selectedVertex = clickedVertex;
                drawGraph();
                event.preventDefault();
            }
        }

        function handleMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            mousePos.x = event.clientX - rect.left;
            mousePos.y = event.clientY - rect.top;
            
            const prevHoveredEdge = hoveredEdge;
            const prevHoveredVertex = hoveredVertex;
            hoveredEdge = null;
            hoveredVertex = null;
            
            hoveredVertex = getVertexAt(mousePos.x, mousePos.y);
            if (!hoveredVertex) {
                hoveredEdge = getEdgeAt(mousePos.x, mousePos.y);
            }
            
            updateCanvasCursor();
            
            if (hoveredEdge !== prevHoveredEdge || hoveredVertex !== prevHoveredVertex) {
                drawGraph();
            }
            
            if (isDragging && dragStartVertex !== null) {
                drawGraph();
                
                const startVertex = graph.vertices.get(dragStartVertex);
                ctx.strokeStyle = '#dc3545';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(startVertex.x, startVertex.y);
                ctx.lineTo(mousePos.x, mousePos.y);
                ctx.stroke();
                ctx.setLineDash([]);
                
                const targetVertex = getVertexAt(mousePos.x, mousePos.y);
                if (targetVertex !== null && targetVertex !== dragStartVertex) {
                    const target = graph.vertices.get(targetVertex);
                    ctx.strokeStyle = '#28a745';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(target.x, target.y, 25, 0, 2 * Math.PI);
                    ctx.stroke();
                }
            }
        }

        function handleMouseUp(event) {
            if (isDragging && dragStartVertex !== null) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                const targetVertex = getVertexAt(x, y);
                
                if (targetVertex !== null && targetVertex !== dragStartVertex) {
                    graph.addEdge(dragStartVertex, targetVertex);
                }
                
                dragCompleted = true;
                setTimeout(() => { dragCompleted = false; }, 100);
                
                isDragging = false;
                dragStartVertex = null;
                selectedVertex = null;
                drawGraph();
                event.preventDefault();
            }
        }

        function handleRightClick(event) {
            event.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const clickedVertex = getVertexAt(x, y);
            
            if (clickedVertex !== null) {
                graph.removeVertex(clickedVertex);
                selectedVertex = null;
                drawGraph();
            } else {
                const clickedEdge = getEdgeAt(x, y);
                if (clickedEdge !== null) {
                    graph.removeEdge(clickedEdge.v1, clickedEdge.v2);
                    drawGraph();
                }
            }
        }

        function getVertexAt(x, y) {
            for (let [id, vertex] of graph.vertices) {
                const dist = Math.sqrt((x - vertex.x) ** 2 + (y - vertex.y) ** 2);
                if (dist <= 20) {
                    return id;
                }
            }
            return null;
        }

        function getEdgeAt(x, y) {
            const threshold = 8;
            
            for (let edge of graph.edges) {
                const v1 = graph.vertices.get(edge.v1);
                const v2 = graph.vertices.get(edge.v2);
                
                const dist = distanceToLineSegment(x, y, v1.x, v1.y, v2.x, v2.y);
                
                if (dist <= threshold) {
                    return edge;
                }
            }
            return null;
        }

        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            if (length === 0) return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);
            
            const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (length * length)));
            const projX = x1 + t * dx;
            const projY = y1 + t * dy;
            
            return Math.sqrt((px - projX) ** 2 + (py - projY) ** 2);
        }

        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let edge of graph.edges) {
                const v1 = graph.vertices.get(edge.v1);
                const v2 = graph.vertices.get(edge.v2);
                
                const isPermanentGreen = permanentGreenPaths.some(path => 
                    (path.from === edge.v1 && path.to === edge.v2) ||
                    (path.from === edge.v2 && path.to === edge.v1)
                );
                
                const isHovered = hoveredEdge && 
                    ((hoveredEdge.v1 === edge.v1 && hoveredEdge.v2 === edge.v2) ||
                    (hoveredEdge.v1 === edge.v2 && hoveredEdge.v2 === edge.v1));
                
                if (isPermanentGreen) {
                    ctx.shadowColor = 'rgba(40, 167, 69, 0.3)';
                    ctx.shadowBlur = 8;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    ctx.strokeStyle = '#28a745';
                    ctx.lineWidth = 4;
                } else if (isHovered) {
                    ctx.shadowColor = 'rgba(220, 53, 69, 0.5)';
                    ctx.shadowBlur = 10;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                    ctx.strokeStyle = '#dc3545';
                    ctx.lineWidth = 4;
                } else {
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    ctx.strokeStyle = '#6c757d';
                    ctx.lineWidth = 2;
                }
                
                ctx.beginPath();
                ctx.moveTo(v1.x, v1.y);
                ctx.lineTo(v2.x, v2.y);
                ctx.stroke();
            }
            
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            for (let [id, vertex] of graph.vertices) {
                const isHovered = hoveredVertex === id;
                const isSelected = selectedVertex === id;
                const isPermanentGreen = permanentGreenVertices.has(id);
                
                if (isPermanentGreen) {
                    ctx.fillStyle = '#28a745';
                } else if (isSelected) {
                    ctx.fillStyle = '#dc3545';
                } else if (isHovered) {
                    ctx.fillStyle = '#28a745';
                } else {
                    ctx.fillStyle = '#667eea';
                }
                
                ctx.beginPath();
                ctx.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.strokeStyle = isPermanentGreen ? '#1e7e34' : '#333';
                ctx.lineWidth = isPermanentGreen ? 3 : 2;
                ctx.stroke();
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(vertex.label, vertex.x, vertex.y);
                
                if (isPermanentGreen) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 10px Arial';
                    ctx.fillText('âœ“', vertex.x + 12, vertex.y - 12);
                }
            }
        }

        function createCompleteGraph() {
            const n = parseInt(document.getElementById('numVertices').value);
            graph.clear();
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) - 50;
            
            for (let i = 0; i < n; i++) {
                const angle = (2 * Math.PI * i) / n;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                graph.addVertex(x, y, i);
            }
            
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    graph.addEdge(i, j);
                }
            }
            
            drawGraph();
        }

        function createCycleGraph() {
            const n = parseInt(document.getElementById('numVertices').value);
            graph.clear();
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) - 50;
            
            for (let i = 0; i < n; i++) {
                const angle = (2 * Math.PI * i) / n;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                graph.addVertex(x, y, i);
            }
            
            for (let i = 0; i < n; i++) {
                graph.addEdge(i, (i + 1) % n);
            }
            
            drawGraph();
        }

        function createPathGraph() {
            const n = parseInt(document.getElementById('numVertices').value);
            graph.clear();
            
            const startX = 50;
            const endX = canvas.width - 50;
            const y = canvas.height / 2;
            const stepX = (endX - startX) / (n - 1);
            
            for (let i = 0; i < n; i++) {
                const x = startX + i * stepX;
                graph.addVertex(x, y, i);
            }
            
            for (let i = 0; i < n - 1; i++) {
                graph.addEdge(i, i + 1);
            }
            
            drawGraph();
        }

        function generateRandomGraph() {
            const n = parseInt(document.getElementById('numVertices').value);
            graph.clear();
            
            for (let i = 0; i < n; i++) {
                const x = 50 + Math.random() * (canvas.width - 100);
                const y = 50 + Math.random() * (canvas.height - 100);
                graph.addVertex(x, y, i);
            }
            
            const maxEdges = n * (n - 1) / 2;
            const numEdges = Math.floor(Math.random() * maxEdges * 0.6) + n - 1;
            
            for (let i = 0; i < numEdges; i++) {
                const v1 = Math.floor(Math.random() * n);
                const v2 = Math.floor(Math.random() * n);
                graph.addEdge(v1, v2);
            }
            
            drawGraph();
            updateCanvasCursor();
            clearPermanentPaths();
            clearResults();
        }

        function clearGraph() {
            graph.clear();
            selectedVertex = null;
            
            clearPermanentPaths();
            
            drawGraph();
            clearResults();
            updateCanvasCursor();
        }

        function clearResults() {
            document.getElementById('eulerPathStatus').innerHTML = '';
            document.getElementById('eulerPathResult').innerHTML = '';
            document.getElementById('eulerCircuitStatus').innerHTML = '';
            document.getElementById('eulerCircuitResult').innerHTML = '';
            document.getElementById('hamiltonPathStatus').innerHTML = '';
            document.getElementById('hamiltonPathResult').innerHTML = '';
            document.getElementById('hamiltonCircuitStatus').innerHTML = '';
            document.getElementById('hamiltonCircuitResult').innerHTML = '';
            document.getElementById('graphInfo').innerHTML = '';
            document.getElementById('matrixDisplay').innerHTML = '';
        }

        function analyzeGraph() {
            if (graph.vertices.size === 0) {
                alert('Tambahkan vertex terlebih dahulu!');
                return;
            }

            const analyzer = new GraphAnalyzer(graph);
            
            const eulerInfo = analyzer.hasEulerPath();
            const eulerPath = analyzer.findEulerPath();

            if (eulerInfo.hasPath && !eulerInfo.hasCircuit) {
                document.getElementById('eulerPathStatus').innerHTML = '<div class="status success">âœ… Memiliki Lintasan Euler</div>';
                document.getElementById('eulerPathResult').innerHTML = eulerPath ? 
                `<div class="path-text">Lintasan Euler: ${eulerPath.join(' â†’ ')}</div>
                <button class="animate-btn" onclick="animatePathfinding('euler-path', ${JSON.stringify(eulerPath)})">ğŸ¬ Animasi</button>` : 
                '<div class="path-text">Lintasan ditemukan</div>';
            } else {
                document.getElementById('eulerPathStatus').innerHTML = '<div class="status error">âŒ Tidak memiliki Lintasan Euler</div>';
                document.getElementById('eulerPathResult').innerHTML = eulerInfo.oddVertices > 2 ? 
                    `Jumlah vertex berderajat ganjil: ${eulerInfo.oddVertices} (harus tepat 2)` : 
                    'Semua vertex berderajat genap (ini adalah sirkuit)';
            }

            if (eulerInfo.hasCircuit) {
                document.getElementById('eulerCircuitStatus').innerHTML = '<div class="status success">âœ… Memiliki Sirkuit Euler</div>';
                document.getElementById('eulerCircuitResult').innerHTML = eulerPath ? 
                `<div class="path-text">Sirkuit Euler: ${eulerPath.join(' â†’ ')}</div>
                <button class="animate-btn" onclick="animatePathfinding('euler-circuit', ${JSON.stringify(eulerPath)})">ğŸ¬ Animasi</button>` : 
                '<div class="path-text">Sirkuit ditemukan</div>';
            } else {
                document.getElementById('eulerCircuitStatus').innerHTML = '<div class="status error">âŒ Tidak memiliki Sirkuit Euler</div>';
                document.getElementById('eulerCircuitResult').innerHTML = eulerInfo.oddVertices === 0 ? 
                    'Graph tidak terhubung' : 
                    `Jumlah vertex berderajat ganjil: ${eulerInfo.oddVertices} (harus 0)`;
            }

            const hamiltonPath = analyzer.findHamiltonPathBacktrack(Array.from(graph.vertices.keys()));
            const hamiltonCircuit = analyzer.findHamiltonCircuitBacktrack(Array.from(graph.vertices.keys()));

            if (hamiltonPath && !hamiltonCircuit) {
                document.getElementById('hamiltonPathStatus').innerHTML = '<div class="status success">âœ… Memiliki Lintasan Hamilton</div>';
                document.getElementById('hamiltonPathResult').innerHTML = 
                `<div class="path-text">Lintasan Hamilton: ${hamiltonPath.join(' â†’ ')}</div>
                <button class="animate-btn" onclick="animatePathfinding('hamilton-path', ${JSON.stringify(hamiltonPath)})">ğŸ¬ Animasi</button>`;
            } else if (!hamiltonPath) {
                document.getElementById('hamiltonPathStatus').innerHTML = '<div class="status error">âŒ Tidak memiliki Lintasan Hamilton</div>';
                document.getElementById('hamiltonPathResult').innerHTML = 'Tidak ditemukan lintasan yang mengunjungi setiap vertex tepat sekali';
            } else {
                document.getElementById('hamiltonPathStatus').innerHTML = '<div class="status warning">âš ï¸ Memiliki Lintasan Hamilton (tapi lebih baik sebagai sirkuit)</div>';
                document.getElementById('hamiltonPathResult').innerHTML = 
                    `Lintasan Hamilton: ${hamiltonPath.join(' â†’ ')} <button class="animate-btn" onclick="animatePathfinding('hamilton-path', ${JSON.stringify(hamiltonPath)})">ğŸ¬ Animasi</button>`;
            }

            if (hamiltonCircuit) {
                document.getElementById('hamiltonCircuitStatus').innerHTML = '<div class="status success">âœ… Memiliki Sirkuit Hamilton</div>';
               document.getElementById('hamiltonCircuitResult').innerHTML = 
                `<div class="path-text">Sirkuit Hamilton: ${hamiltonCircuit.join(' â†’ ')}</div>
                <button class="animate-btn" onclick="animatePathfinding('hamilton-circuit', ${JSON.stringify(hamiltonCircuit)})">ğŸ¬ Animasi</button>`;
            } else {
                document.getElementById('hamiltonCircuitStatus').innerHTML = '<div class="status error">âŒ Tidak memiliki Sirkuit Hamilton</div>';
                const hamiltonInfo = analyzer.hasHamiltonPath();
                document.getElementById('hamiltonCircuitResult').innerHTML = hamiltonInfo.diracCondition ? 
                    'Kondisi Dirac terpenuhi tapi tidak ditemukan sirkuit' : 
                    'Kondisi Dirac tidak terpenuhi untuk sirkuit Hamilton';
            }
            
            const degrees = [];
            for (let vertex of graph.vertices.keys()) {
                degrees.push(graph.getDegree(vertex));
            }

            const graphInfo = `Jumlah Titik/Node: ${graph.vertices.size}
Jumlah Sisi: ${graph.edges.length}
Derajat setiap Titik/Node: ${Array.from(graph.vertices.keys()).map(v => `${v}:${graph.getDegree(v)}`).join(', ')}
Total derajat: ${degrees.reduce((a, b) => a + b, 0)}
Derajat minimum: ${Math.min(...degrees)}
Derajat maksimum: ${Math.max(...degrees)}`;

            document.getElementById('graphInfo').innerHTML = graphInfo;
            
            document.getElementById('eulerStatus').innerHTML = eulerStatus;
            document.getElementById('eulerResult').innerHTML = eulerResult;
            document.getElementById('hamiltonStatus').innerHTML = hamiltonStatus;
            document.getElementById('hamiltonResult').innerHTML = hamiltonResult;
            document.getElementById('graphInfo').innerHTML = graphInfo;
        }

        function showAdjacencyMatrix() {
            if (graph.vertices.size === 0) {
                document.getElementById('matrixDisplay').innerHTML = 'Tidak ada vertex dalam graph';
                return;
            }

            const vertices = Array.from(graph.vertices.keys()).sort((a, b) => a - b);
            const n = vertices.length;
            const matrix = Array(n).fill().map(() => Array(n).fill(0));
            
            for (let edge of graph.edges) {
                const i = vertices.indexOf(edge.v1);
                const j = vertices.indexOf(edge.v2);
                matrix[i][j] = 1;
                matrix[j][i] = 1;
            }
            
            let html = '<table style="margin: 0 auto; border-collapse: collapse;">';
            html += '<tr><th style="padding: 5px; border: 1px solid #ccc; background: #f8f9fa;"></th>';
            
            for (let vertex of vertices) {
                html += `<th style="padding: 5px; border: 1px solid #ccc; background: #f8f9fa;">${vertex}</th>`;
            }
            html += '</tr>'; 
            for (let i = 0; i < n; i++) {
                html += `<tr><th style="padding: 5px; border: 1px solid #ccc; background: #f8f9fa;">${vertices[i]}</th>`;
                for (let j = 0; j < n; j++) {
                    const cellColor = matrix[i][j] === 1 ? '#d4edda' : '#ffffff';
                    html += `<td style="padding: 5px; border: 1px solid #ccc; text-align: center; background: ${cellColor};">${matrix[i][j]}</td>`;
                }
                html += '</tr>';
            }
            html += '</table>';
            
            document.getElementById('matrixDisplay').innerHTML = html;
        }

        function animatePath() {
            if (animationRunning) return;
            
            const analyzer = new GraphAnalyzer(graph);
            const eulerPath = analyzer.findEulerPath();
            const hamiltonPath = analyzer.findHamiltonPathBacktrack(Array.from(graph.vertices.keys()));
            
            let pathToAnimate = eulerPath || hamiltonPath;
            
            if (!pathToAnimate) {
                alert('Tidak ada path yang bisa dianimasi!');
                return;
            }
            
            animationRunning = true;
            let currentIndex = 0;
            
            const animateStep = () => {
                if (currentIndex >= pathToAnimate.length - 1) {
                    animationRunning = false;
                    drawGraph();
                    return;
                }
                
                drawGraph();
                
                const currentVertex = pathToAnimate[currentIndex];
                const nextVertex = pathToAnimate[currentIndex + 1];
                
                const v1 = graph.vertices.get(currentVertex);
                const v2 = graph.vertices.get(nextVertex);
                
                ctx.strokeStyle = '#dc3545';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(v1.x, v1.y);
                ctx.lineTo(v2.x, v2.y);
                ctx.stroke();
                
                ctx.fillStyle = '#dc3545';
                ctx.beginPath();
                ctx.arc(v1.x, v1.y, 22, 0, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(v2.x, v2.y, 22, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(v1.label, v1.x, v1.y);
                ctx.fillText(v2.label, v2.x, v2.y);
                
                currentIndex++;
                setTimeout(animateStep, 800);
            };
            
            animateStep();
        }

        function openInstructionsModal() {
            document.getElementById('instructionsModal').style.display = 'block';
            document.body.style.overflow = 'hidden';
        }

        function closeInstructionsModal() {
            document.getElementById('instructionsModal').style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        window.onclick = function(event) {
            const modal = document.getElementById('instructionsModal');
            if (event.target === modal) {
                closeInstructionsModal();
            }
        }

        function updateCanvasCursor() {
            canvas.classList.remove('empty', 'has-content', 'hovering-edge');
            
            if (graph.vertices.size === 0 && graph.edges.length === 0) {
                canvas.classList.add('empty');
            } else {
                canvas.classList.add('has-content');
                
                if (hoveredEdge) {
                    canvas.style.cursor = 'pointer';
                } else if (hoveredVertex) {
                    canvas.style.cursor = 'grab';
                } else {
                    canvas.style.cursor = 'crosshair';
                }
            }
        }
        function animatePathfinding(pathType, correctPath) {
            if (pathAnimationRunning) {
                alert('Animasi sedang berjalan!');
                return;
            }
            
            permanentGreenPaths = [];
            permanentGreenVertices.clear();
            
            pathAnimationRunning = true;
            
            const animateButtons = document.querySelectorAll('.animate-btn');
            animateButtons.forEach(btn => btn.disabled = true);
            
            const vertices = Array.from(graph.vertices.keys());
            const adj = graph.getAdjacencyList();
            
            const explorationSequence = generateExplorationPaths(correctPath, adj, vertices);
            
            let sequenceIndex = 0;
            let currentPath = [];
            let visitedVertices = new Set();
            
            const animateExploration = () => {
                if (sequenceIndex >= explorationSequence.length) {
                    pathAnimationRunning = false;
                    animateButtons.forEach(btn => btn.disabled = false);
                    drawGraph();
                    showCompletionMessage(pathType);
                    return;
                }
                
                const step = explorationSequence[sequenceIndex];
                
                if (step.action === 'explore') {
                    exploreWrongPath(step.from, step.to, step.isCorrect);
                } else if (step.action === 'backtrack') {
                    backtrackAnimation(step.from, step.to);
                } else if (step.action === 'correct') {
                    addCorrectPath(step.from, step.to);
                    
                    permanentGreenPaths.push({ from: step.from, to: step.to });
                    permanentGreenVertices.add(step.from);
                    permanentGreenVertices.add(step.to);
                    
                    visitedVertices.add(step.from);
                    visitedVertices.add(step.to);
                }
                
                sequenceIndex++;
                setTimeout(animateExploration, animationSpeed);
            };
            
            drawGraph();
            setTimeout(animateExploration, 500);
        }

        function generateExplorationPaths(correctPath, adj, vertices) {
            const sequence = [];
            const visited = new Set();
            
            for (let i = 0; i < correctPath.length - 1; i++) {
                const current = correctPath[i];
                const next = correctPath[i + 1];
                const neighbors = adj.get(current);
                
                const wrongNeighbors = neighbors.filter(n => n !== next && !visited.has(n));
                const numWrongExplore = Math.min(2, wrongNeighbors.length);
                
                for (let j = 0; j < numWrongExplore; j++) {
                    const wrongNext = wrongNeighbors[j];
                    sequence.push({ action: 'explore', from: current, to: wrongNext, isCorrect: false });
                    sequence.push({ action: 'backtrack', from: wrongNext, to: current });
                }
                
                sequence.push({ action: 'correct', from: current, to: next });
                visited.add(current);
            }
            
            return sequence;
        }

        function exploreWrongPath(from, to) {
            drawGraph();
            
            const fromVertex = graph.vertices.get(from);
            const toVertex = graph.vertices.get(to);
            
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            ctx.setLineDash([8, 4]);
            ctx.beginPath();
            ctx.moveTo(fromVertex.x, fromVertex.y);
            ctx.lineTo(toVertex.x, toVertex.y);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#ff6b6b';
            ctx.beginPath();
            ctx.arc(fromVertex.x, fromVertex.y, 25, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(toVertex.x, toVertex.y, 25, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('?', toVertex.x, toVertex.y);
            ctx.fillText(fromVertex.label, fromVertex.x, fromVertex.y);
        }

        function backtrackAnimation(from, to) {
            drawGraph();
            
            const fromVertex = graph.vertices.get(from);
            const toVertex = graph.vertices.get(to);
            
            ctx.strokeStyle = '#ffc107';
            ctx.lineWidth = 4;
            ctx.setLineDash([]);
            
            const midX = (fromVertex.x + toVertex.x) / 2;
            const midY = (fromVertex.y + toVertex.y) / 2 - 30;
            
            ctx.beginPath();
            ctx.moveTo(fromVertex.x, fromVertex.y);
            ctx.quadraticCurveTo(midX, midY, toVertex.x, toVertex.y);
            ctx.stroke();
            
            const angle = Math.atan2(toVertex.y - midY, toVertex.x - midX);
            ctx.fillStyle = '#ffc107';
            ctx.beginPath();
            ctx.moveTo(toVertex.x, toVertex.y);
            ctx.lineTo(toVertex.x - 10 * Math.cos(angle - Math.PI/6), toVertex.y - 10 * Math.sin(angle - Math.PI/6));
            ctx.lineTo(toVertex.x - 10 * Math.cos(angle + Math.PI/6), toVertex.y - 10 * Math.sin(angle + Math.PI/6));
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = '#ffc107';
            ctx.beginPath();
            ctx.arc(toVertex.x, toVertex.y, 25, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(toVertex.label, toVertex.x, toVertex.y);
        }

        function addCorrectPath(from, to) {
            drawGraph();
            
            const fromVertex = graph.vertices.get(from);
            const toVertex = graph.vertices.get(to);
            
            ctx.strokeStyle = '#28a745';
            ctx.lineWidth = 5;
            ctx.setLineDash([]);
            ctx.shadowColor = 'rgba(40, 167, 69, 0.5)';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(fromVertex.x, fromVertex.y);
            ctx.lineTo(toVertex.x, toVertex.y);
            ctx.stroke();
            
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            
            ctx.fillStyle = '#28a745';
            ctx.beginPath();
            ctx.arc(fromVertex.x, fromVertex.y, 25, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(toVertex.x, toVertex.y, 25, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.strokeStyle = '#1e7e34';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(fromVertex.x, fromVertex.y, 25, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(toVertex.x, toVertex.y, 25, 0, 2 * Math.PI);
            ctx.stroke();
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(fromVertex.label, fromVertex.x, fromVertex.y);
            ctx.fillText(toVertex.label, toVertex.x, toVertex.y);
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px Arial';
            ctx.fillText('âœ“', toVertex.x + 15, toVertex.y - 15);
        }

        function clearPermanentPaths() {
            permanentGreenPaths = [];
            permanentGreenVertices.clear();
            drawGraph();
        }

        function showCompletionMessage(pathType) {
            const messages = {
                'euler-path': 'Lintasan Euler berhasil ditemukan! ğŸ‰',
                'euler-circuit': 'Sirkuit Euler berhasil ditemukan! ğŸ‰',
                'hamilton-path': 'Lintasan Hamilton berhasil ditemukan! ğŸ‰',
                'hamilton-circuit': 'Sirkuit Hamilton berhasil ditemukan! ğŸ‰'
            };
            
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(45deg, #28a745, #20c997);
                color: white;
                padding: 20px 30px;
                border-radius: 15px;
                font-size: 18px;
                font-weight: bold;
                box-shadow: 0 8px 25px rgba(0,0,0,0.3);
                z-index: 1000;
                animation: successPulse 0.6s ease-out;
            `;
            
            messageDiv.textContent = messages[pathType];
            document.body.appendChild(messageDiv);
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes successPulse {
                    0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
                    50% { transform: translate(-50%, -50%) scale(1.1); }
                    100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                }
            `;
            document.head.appendChild(style);
            
            setTimeout(() => {
                document.body.removeChild(messageDiv);
                document.head.removeChild(style);
            }, 3000);
        }

        function openTheoryModal(type) {
            const modalIds = {
                'euler': 'eulerTheoryModal',
                'hamilton': 'hamiltonTheoryModal',
                'graph-basics': 'graphBasicsTheoryModal',
                'differences': 'differencesTheoryModal',
                'applications': 'applicationsTheoryModal'
            };
            
            const modalId = modalIds[type];
            if (modalId) {
                document.getElementById(modalId).style.display = 'block';
                document.body.style.overflow = 'hidden';
            }
        }

        function closeTheoryModal(type) {
            const modalIds = {
                'euler': 'eulerTheoryModal',
                'hamilton': 'hamiltonTheoryModal',
                'graph-basics': 'graphBasicsTheoryModal',
                'differences': 'differencesTheoryModal',
                'applications': 'applicationsTheoryModal'
            };
            
            const modalId = modalIds[type];
            if (modalId) {
                document.getElementById(modalId).style.display = 'none';
                document.body.style.overflow = 'auto';
            }
        }

        window.addEventListener('click', function(event) {
            const modals = ['eulerTheoryModal', 'hamiltonTheoryModal', 'graphBasicsTheoryModal', 'differencesTheoryModal', 'applicationsTheoryModal'];
            
            modals.forEach(modalId => {
                const modal = document.getElementById(modalId);
                if (event.target === modal) {
                    modal.style.display = 'none';
                    document.body.style.overflow = 'auto';
                }
            });
        });

        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const modals = ['eulerTheoryModal', 'hamiltonTheoryModal', 'graphBasicsTheoryModal', 'differencesTheoryModal', 'applicationsTheoryModal'];
                
                modals.forEach(modalId => {
                    const modal = document.getElementById(modalId);
                    if (modal.style.display === 'block') {
                        modal.style.display = 'none';
                        document.body.style.overflow = 'auto';
                    }
                });
            }
        });
    </script>
</body>
</html>
